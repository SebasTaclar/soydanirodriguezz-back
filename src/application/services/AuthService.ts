import { generateToken } from '../../shared/jwtHelper';
import { Logger } from '../../shared/Logger';
import { PasswordUtils } from '../../shared/PasswordUtils';
import { ValidationError, AuthenticationError } from '../../shared/exceptions';
import { IUserDataSource } from '../../domain/interfaces/IUserDataSource';

export interface LoginRequest {
  email: string;
  password: string;
}

export interface UserInfo {
  id: string;
  email: string;
  role: string;
  name: string;
  membershipPaid: boolean;
}

export interface CreateUserRequest {
  email: string;
  password: string;
  name: string;
  role: string;
  membershipPaid?: boolean;
}

export class AuthService {
  private logger: Logger;
  private userDataSource: IUserDataSource;

  constructor(logger: Logger, userDataSource: IUserDataSource) {
    this.logger = logger;
    this.userDataSource = userDataSource;
  }

  async login(loginRequest: LoginRequest): Promise<string> {
    const { email, password } = loginRequest;

    this.logger.logInfo(`Login attempt for user: ${email}`);

    if (!email || !password) {
      this.logger.logWarning('Login failed: missing email or password');
      throw new ValidationError('Email and password are required');
    }

    // Get user by email from data source
    const user = await this.userDataSource.getByEmail(email);

    if (!user) {
      this.logger.logWarning(`Login failed for user: ${email} - user not found`);
      throw new AuthenticationError('Invalid credentials');
    }

    // Validate password using centralized utility
    const isValidPassword = await PasswordUtils.comparePassword(password, user.password);

    if (!isValidPassword) {
      this.logger.logWarning(`Login failed for user: ${email} - invalid password`);
      throw new AuthenticationError('Invalid credentials');
    }

    const token = generateToken({
      id: user.id,
      email: user.email,
      role: user.role,
      name: user.name,
      membershipPaid: user.membershipPaid,
    });

    this.logger.logInfo(`Login successful for user: ${email} with role: ${user.role}`);

    return token;
  }

  async createUser(createUserRequest: CreateUserRequest): Promise<UserInfo> {
    const { email, password, name, role, membershipPaid = false } = createUserRequest;

    this.logger.logInfo(`Creating user: ${email}`);

    if (!email || !password || !name || !role) {
      this.logger.logWarning('User creation failed: missing required fields');
      throw new ValidationError('Email, password, name, and role are required');
    }

    // Validate password requirements
    PasswordUtils.validatePassword(password);

    // Check if user already exists
    const existingUser = await this.userDataSource.getByEmail(email);
    if (existingUser) {
      this.logger.logWarning(`User creation failed: email ${email} already exists`);
      throw new ValidationError('Email already exists');
    }

    // Hash password using centralized utility
    const hashedPassword = await PasswordUtils.hashPassword(password);

    // Create user object
    const newUser = {
      id: 0, // Will be generated by database
      email,
      password: hashedPassword,
      name,
      role,
      membershipPaid,
    };

    try {
      const createdUser = await this.userDataSource.create(newUser);

      this.logger.logInfo(`User created successfully: ${email} with role: ${role}`);

      return {
        id: createdUser.id.toString(),
        email: createdUser.email,
        name: createdUser.name,
        role: createdUser.role,
        membershipPaid: createdUser.membershipPaid,
      };
    } catch (error) {
      this.logger.logError(`Error creating user: ${email}`, error);
      throw error;
    }
  }
}
